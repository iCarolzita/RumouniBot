# Este c√≥digo foi feito por Carolina Fernandes
# bot.py
# Bot de Telegram para alunos do ensino secund√°rio
# Usa OpenAI para gerar todas as respostas educativas em PT-PT
# 
# Para iniciar o bot no Telegram, envie o comando /start ao bot.
# Certifique-se de que as vari√°veis de ambiente est√£o configuradas (.env).

import os
import random
import nest_asyncio
from dotenv import load_dotenv
import openai
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes,
    CallbackQueryHandler,
)

# Permite a execu√ß√£o de c√≥digo ass√≠ncrono em ambientes que n√£o suportam asyncio nativamente
nest_asyncio.apply()

# =======================
# CONFIGURA√á√ÉO
# =======================
load_dotenv()  # Carrega vari√°veis de ambiente do ficheiro .env
openai.api_key = os.getenv("OPENAI_API_KEY")  # Chave da API OpenAI
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")  # Token do bot Telegram
CHAT_ID_ALERTA = int(os.getenv("CHAT_ID_ALERTA", "0"))  # ID do chat para alertas (opcional)

# Dicion√°rio para guardar o hist√≥rico de conversas de cada utilizador
historico_usuarios = {}

# =======================
# LINKS REAIS PARA CURSOS
# =======================
# Dicion√°rio com links oficiais para cursos populares
cursos_links = {
    "Medicina": "[Faculdade de Medicina da Univ. do Porto](https://sigarra.up.pt/fmup/pt/web_page.inicial)",
    "Engenharia Inform√°tica": "[Faculdade de Ci√™ncias e Tecnologia da Univ. Coimbra](https://www.uc.pt/fctuc)",
    "Gest√£o": "[ISCTE Business School](https://www.iscte-iul.pt/ensino/bs)",
    "Direito": "[Faculdade de Direito da Univ. Lisboa](https://www.fd.ulisboa.pt/pt)",
    "Psicologia": "[Faculdade de Psicologia da Univ. Lisboa](https://www.psicologia.ulisboa.pt/pt)"
}

# =======================
# FUN√á√ÉO AUXILIAR OPENAI
# =======================
async def perguntar_openai(prompt: str, max_tokens: int = 400) -> str:
    """Envia um prompt √† OpenAI e devolve a resposta como texto limpo"""
    try:
        resposta = openai.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[{"role": "user", "content": prompt}],
            max_tokens=max_tokens
        )
        return resposta.choices[0].message.content.strip()
    except Exception:
        return "N√£o foi poss√≠vel obter resposta neste momento. ü§î"

# =======================
# FUN√á√ÉO PARA MENSAGENS LONGAS (SEM CORTAR FRASES)
# =======================
async def enviar_texto_long(update, texto, parse_mode="Markdown"):
    """
    Divide mensagens longas em blocos de at√© 4000 caracteres sem cortar frases.
    Tenta separar por par√°grafos ou pontos finais.
    """
    max_len = 4000
    partes = []

    while len(texto) > max_len:
        # Procura o √∫ltimo ponto ou quebra de linha antes do limite
        split_pos = max(texto.rfind('\n', 0, max_len), texto.rfind('. ', 0, max_len))
        if split_pos == -1:
            split_pos = max_len  # Se n√£o encontrar, corta no limite
        partes.append(texto[:split_pos+1].strip())
        texto = texto[split_pos+1:].strip()

    if texto:
        partes.append(texto)

    for parte in partes:
        await update.message.reply_text(parte, parse_mode=parse_mode)

# =======================
# COMANDOS DO BOT
# =======================
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    # Inicializa o hist√≥rico do utilizador ao iniciar o bot
    usuario_id = update.message.from_user.id
    historico_usuarios[usuario_id] = []

    await update.message.reply_text(
        "*Ol√°! üëã Eu sou o RumouniBot.*\n\n"
        "Podes perguntar-me sobre cursos universit√°rios e notas de entrada.\n\n"
        "üìå *Comandos √∫teis:*\n"
        "  /curiosidade - curiosidades sobre cursos üéì\n"
        "  /dica - dicas motivacionais üí°\n"
        "  /ranking - cursos mais concorridos üèÜ\n"
        "  /universidades - resumos r√°pidos de universidades üè´\n"
        "  /sobre - informa√ß√µes e links √∫teis üîó",
        parse_mode="Markdown"
    )

async def curiosidade(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    # Gera uma curiosidade educativa sobre cursos universit√°rios
    prompt = "Gera uma curiosidade educativa sobre cursos universit√°rios em Portugal. Usa emojis e linguagem curta para alunos do secund√°rio."
    texto = await perguntar_openai(prompt, 100)
    await enviar_texto_long(update, texto)

async def dica(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    # Gera uma dica motivacional para alunos do secund√°rio
    prompt = "Gera uma dica motivacional para alunos do ensino secund√°rio, sobre estudar, notas e motiva√ß√£o. Usa emojis e linguagem curta."
    texto = await perguntar_openai(prompt, 80)
    await enviar_texto_long(update, texto)

async def ranking(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    # Lista os cursos mais concorridos e insere links oficiais
    prompt = (
        "Lista os 5 cursos universit√°rios mais concorridos em Portugal em 2025. "
        "Para cada curso, escreve uma curiosidade educativa de 1 linha e a nota m√©dia de entrada. "
        "N√£o coloques links, vamos usar os links oficiais do dicion√°rio. "
        "Formata em Markdown."
    )
    texto = await perguntar_openai(prompt, max_tokens=400)

    # Substitui os placeholders pelos links reais dos cursos
    for curso, link_md in cursos_links.items():
        texto = texto.replace(f"{curso} - Link oficial", f"{link_md}")
        if curso in texto:
            texto = texto.replace(curso, f"{curso} - {link_md}")

    await enviar_texto_long(update, texto)

async def universidades(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    # Mostra as primeiras universidades e prepara bot√£o para ver mais
    context.user_data["contador_universidades"] = 0
    context.user_data["universidades_mostradas"] = []

    prompt = "Gera uma lista das 3 primeiras universidades de Portugal com breve descri√ß√£o educativa e emojis. Sem numera√ß√£o."
    novas = await perguntar_openai(prompt, 150)
    novas_universidades = [linha.strip() for linha in novas.split("\n") if linha.strip()]

    texto_numerado = ""
    for uni in novas_universidades:
        context.user_data["contador_universidades"] += 1
        texto_numerado += f"{context.user_data['contador_universidades']}. {uni}\n"

    context.user_data["universidades_mostradas"] = [texto_numerado]

    keyboard = InlineKeyboardMarkup([[InlineKeyboardButton("Ver mais 3 universidades", callback_data="mostrar_3")]])
    await update.message.reply_text(texto_numerado, reply_markup=keyboard)

async def button(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    # Mostra mais universidades quando o utilizador clica no bot√£o
    query = update.callback_query
    await query.answer()

    if query.data == "mostrar_3":
        contador = context.user_data.get("contador_universidades", 0)
        ja_mostradas = context.user_data.get("universidades_mostradas", [])

        prompt = "Gera 3 universidades em Portugal que ainda n√£o foram mencionadas, cada uma com resumo educativo de 2-3 linhas e emojis. Sem numera√ß√£o."
        novas = await perguntar_openai(prompt, 150)
        novas_universidades = [linha.strip() for linha in novas.split("\n") if linha.strip()]

        texto_numerado = ""
        for uni in novas_universidades:
            contador += 1
            texto_numerado += f"{contador}. {uni}\n"

        ja_mostradas.append(texto_numerado)
        context.user_data["contador_universidades"] = contador
        context.user_data["universidades_mostradas"] = ja_mostradas

        # Limita a apresenta√ß√£o a 18 universidades
        if contador >= 18:
            keyboard = None
        else:
            keyboard = InlineKeyboardMarkup([[InlineKeyboardButton("Ver mais 3 universidades", callback_data="mostrar_3")]])

        await query.edit_message_text("\n".join(ja_mostradas), reply_markup=keyboard)

async def sobre(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    # Explica a utilidade do bot e adiciona links √∫teis
    prompt = (
        "Escreve uma mensagem educativa e amig√°vel explicando a utilidade de um bot "
        "para alunos do ensino secund√°rio. Inclui exemplos de como pode ajudar nos estudos, "
        "resumos de cursos, dicas e links √∫teis de universidades e ensino superior em Portugal. "
        "Termina a mensagem com uma conclus√£o motivacional completa. "
        "N√£o cortes frases no final. Garante que a resposta seja cont√≠nua e completa. "
        "Formata em Markdown para Telegram."
    )
    texto = await perguntar_openai(prompt, max_tokens=400)

    # Adiciona links √∫teis fixos √† mensagem
    links_utiles = "\n\nLinks √∫teis:\n- [DGES](https://www.dges.gov.pt)\n- [Universia Portugal](https://www.universia.pt)\n- [Estudante.pt](https://www.estudante.pt)"
    texto += links_utiles

    await enviar_texto_long(update, texto)

# =======================
# RESPOSTAS LIVRES
# =======================
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    # Responde a perguntas livres, mantendo o hist√≥rico do utilizador
    usuario_id = update.message.from_user.id
    user_text = update.message.text

    if usuario_id not in historico_usuarios:
        historico_usuarios[usuario_id] = []

    historico_usuarios[usuario_id].append({"role": "user", "content": user_text})
    historico_usuarios[usuario_id] = historico_usuarios[usuario_id][-10:]  # Mant√©m apenas as √∫ltimas 10 mensagens

    # Mensagem de sistema para orientar a IA a responder em PT-PT e de forma educativa
    system_message = (
        "√âs um assistente educativo em Portugu√™s de Portugal. "
        "Responde de forma clara, natural e amig√°vel sobre cursos e notas. "
        "Inclui exemplos de notas t√≠picas, sugere cursos por nota, explica termos dif√≠ceis, usa emojis e links quando poss√≠vel."
    )

    mensagens_gpt = [{"role": "system", "content": system_message}] + historico_usuarios[usuario_id]

    try:
        resposta = openai.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=mensagens_gpt,
            max_tokens=400
        )
        bot_reply = resposta.choices[0].message.content.strip()
        # Acrescenta uma frase motivacional aleat√≥ria no final da resposta
        frases_motivacionais = [
            "Lembra-te: cada esfor√ßo conta! üåü",
            "Continua a estudar, vais conseguir! üí™",
            "O teu futuro depende do que fazes hoje! üìö‚ú®"
        ]
        bot_reply += f"\n\n_{random.choice(frases_motivacionais)}_"
        historico_usuarios[usuario_id].append({"role": "assistant", "content": bot_reply})
    except Exception:
        bot_reply = "Desculpa, houve um problema a processar a tua pergunta. ü§î"

    await enviar_texto_long(update, bot_reply)

# =======================
# CONFIGURA√á√ÉO DO BOT
# =======================
def main():
    # Inicializa a aplica√ß√£o do Telegram e regista os handlers dos comandos
    app = Application.builder().token(TELEGRAM_TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("curiosidade", curiosidade))
    app.add_handler(CommandHandler("dica", dica))
    app.add_handler(CommandHandler("ranking", ranking))
    app.add_handler(CommandHandler("universidades", universidades))
    app.add_handler(CommandHandler("sobre", sobre))
    app.add_handler(CallbackQueryHandler(button))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    app.run_polling()  # Inicia o bot e fica √† escuta de mensagens

if __name__ == "__main__":
    main()
